<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 有鸟止南方之阜</title>
    <link>https://kunpengdai.github.io/post/</link>
    <description>Recent content in Posts on 有鸟止南方之阜</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 03 Nov 2023 23:27:08 +0800</lastBuildDate>
    <atom:link href="https://kunpengdai.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>食材单词</title>
      <link>https://kunpengdai.github.io/post/2023/%E9%A3%9F%E6%9D%90%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Fri, 03 Nov 2023 23:27:08 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2023/%E9%A3%9F%E6%9D%90%E5%8D%95%E8%AF%8D/</guid>
      <description>以下是常用的食材和调料的英语名称： 食材： 食材 英语名称 大米 Rice 意大利面 Pasta 鸡肉 Chicken 牛肉 Beef 猪肉 Pork 鱼 Fish 虾 Shrimp 鸡蛋 Eggs 豆腐 Tofu 三文鱼 Salmon 火鸡肉 Turkey 羊肉 Lamb 绞肉 Ground beef 香肠 Sausage 培根 Bacon 火腿 Ham 洋葱 Onion 大蒜 Garlic 西红柿 Tomato 胡萝卜 Carrot 土豆 Potato 甜椒 Bell pepper 蘑菇 Mushroom 花椰菜 Broccoli 菠菜 Spinach 生菜 Lettuce 黄瓜 Cucumber 西葫芦 Zucchini 鳄梨 Avocado 茄子 Eggplant 玉米 Corn 青豆 Green beans 豌豆 Peas 芦笋 Asparagus 花菜 Cauliflower</description>
    </item>
    <item>
      <title>杨浦图书馆日流量爬虫</title>
      <link>https://kunpengdai.github.io/post/2020/%E6%9D%A8%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%97%A5%E6%B5%81%E9%87%8F%E7%88%AC%E8%99%AB/</link>
      <pubDate>Sun, 15 Mar 2020 22:57:08 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2020/%E6%9D%A8%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%97%A5%E6%B5%81%E9%87%8F%E7%88%AC%E8%99%AB/</guid>
      <description>背景 新居住的地方在离上海市的杨浦图书馆很近。杨浦图书馆由民国时期的旧上海图书馆修缮扩建而成。进入其中，学习氛围与历史气息合而为一，是我周末最喜欢待的地方。不过图书馆占地面积过小，楼层也只有两层，美则美矣，周末想占个位置还是很难的。 根据之前的观察，馆内人数在300人左右时，就很难再</description>
    </item>
    <item>
      <title>TCP拥塞控制算法</title>
      <link>https://kunpengdai.github.io/post/2019/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 25 Dec 2019 07:51:02 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</guid>
      <description>基础知识 运作方式 TCP 使用多用拥塞控制策略来避免雪崩式拥塞。TCP会为每条连接维护一个“拥塞窗口”来限制可能在端对端间传输的未确认分组总数量。这类似于TCP流量控制机制中使用的滑动窗口。TCP在一个连接初始化或超时后使用一种“慢启动”机制来增加拥塞窗口的大小。其起始值一般为最大分段大</description>
    </item>
    <item>
      <title>Redis Bitmap</title>
      <link>https://kunpengdai.github.io/post/2019/redis-bitmap/</link>
      <pubDate>Sat, 24 Aug 2019 22:12:12 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/redis-bitmap/</guid>
      <description>redis bitmap简介 redis中的bitmap是一串连续的2进制数字，每一位所在的位置为偏移，在bitmap上可以执行AND，OR，XOR，NOT等位操作。 bitmap中保存每个位置的数据仅使用了一个bit，而对应的数据的存储根据大小在bitmap中相对应offset。 一个简单的例</description>
    </item>
    <item>
      <title>Redis 数据结构</title>
      <link>https://kunpengdai.github.io/post/2019/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 23 Jul 2019 14:24:45 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>数据结构 SDS/simple dynamic strings 1 2 3 4 5 6 7 8 9 10 11 12 13 struct sdshdr { // 记录 buf 数组中已使用字节的数量 // 等于 SDS 所保存字符串的长度 int len; // 记录 buf 数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[]; }; SDS遵循C语言的规则，在字符串末尾添加了&amp;rsquo;\0&amp;rsquo;,这样就可以直接使用C字符串函数库</description>
    </item>
    <item>
      <title>分布式锁</title>
      <link>https://kunpengdai.github.io/post/2019/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Fri, 05 Jul 2019 08:05:08 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>背景 在分布式环境下，需要控制多个节点对同一个资源的并发访问，此时本地的加锁已经不能满足需要。为了实现在分布式环境下的锁。 使用场景 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。 正确性:加分布式锁同样可以避免破坏</description>
    </item>
    <item>
      <title>Redis持久化与同步</title>
      <link>https://kunpengdai.github.io/post/2019/redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 28 May 2019 15:34:09 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%8E%E5%90%8C%E6%AD%A5/</guid>
      <description>持久化 redis 持久化有两种方式，RDB与AOF。 RDB 优点: 利于备份 适用于故障恢复 比AOF重启更快 缺点: 备份会造成更大的数据损失 需要使用fork子进程来持久化数据到盘上，如果数据量较大，会造成同步期间短暂的停止服务。 AOF 优点: 持久化做的更好，可以选择三种同步策略，不同步、一秒同步一次，每次更</description>
    </item>
    <item>
      <title>网络编程</title>
      <link>https://kunpengdai.github.io/post/2019/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 03 May 2019 15:51:09 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description>客户端-服务器编程模型 每个网络应用都是基于客户端-服务器模型的。基于这个模型，一个应用是由一个服务器进程和一个或多个客户端进程组成。服务器管理者某种资源，并利用这种资源为其他客户端提供服务。 常见的类型有：web服务器，FTP服务器，电子邮件服务器等。 套接字编程 套接字接口流程图 套接</description>
    </item>
    <item>
      <title>Go临时对象池pool原理解析</title>
      <link>https://kunpengdai.github.io/post/2019/Go%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B1%A0pool%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 12 Apr 2019 20:07:58 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/Go%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B1%A0pool%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</guid>
      <description>临时对象池是啥？ 查看sync.Pool中的注释来了解pool的基本用法。主要有以下几点： pool是一个可以存储和取出临时对象的临时对象池。 池中的对象会在没有通知的情况下自动删除，如果一个对象池持有某个对象的唯一引用，那么该对象很有可能被回收。 pool是多goroutine并发安全</description>
    </item>
    <item>
      <title>Go Interface 原理解析</title>
      <link>https://kunpengdai.github.io/post/2019/go-interface-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 13 Mar 2019 21:46:30 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/go-interface-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</guid>
      <description>概述 在Go中的，interface是一个非常重要的概念，一般情况下会有两种用法，一种类似于Java语言的接口的概念，作为Go语言中的一组方法的定义；一种类似于c 中的void *的概念，是Go中的抽象类型。 方法 比如经常使用的Context类型，只定义了其方法的集合，具体的类型可以有不</description>
    </item>
    <item>
      <title>合成复用原则</title>
      <link>https://kunpengdai.github.io/post/2019/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 28 Jun 2018 08:41:18 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99/</guid>
      <description>定义 合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）：它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。 如果要使用继承关心，必</description>
    </item>
    <item>
      <title>迪米特法则</title>
      <link>https://kunpengdai.github.io/post/2019/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Thu, 28 Jun 2018 08:27:57 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>定义 迪米特法则（Law of Demeter）：又称最少知识原则（Least Knowledge Principle，LKP），只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发</description>
    </item>
    <item>
      <title>接口隔离原则</title>
      <link>https://kunpengdai.github.io/post/2019/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 28 Jun 2018 08:16:33 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      <description>定义 接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小和更具体的接口，让接口中只包含客户感兴趣的方法。定义：客户端不应该被迫依赖于它不适用的方法（Clients should not be forced to depend on methods they do not use）。该原则还有另外一个定义：一个类对另一</description>
    </item>
    <item>
      <title>单一职责原则</title>
      <link>https://kunpengdai.github.io/post/2019/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</link>
      <pubDate>Thu, 28 Jun 2018 08:05:42 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3/</guid>
      <description>定义 单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则：规定一个类应该且仅有一个引起它变化的原因，否则类应该被拆分。 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力</description>
    </item>
    <item>
      <title>依赖倒置原则</title>
      <link>https://kunpengdai.github.io/post/2019/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>Wed, 27 Jun 2018 08:42:55 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</guid>
      <description>定义 依赖倒置原则（Dependence Inversion Principle，DIP）：高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象（High level modules shouldnot depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details. Details should depend upon abstractions）。其核心思想是面向接口编程，不要面向实现编程.</description>
    </item>
    <item>
      <title>开放闭合原则</title>
      <link>https://kunpengdai.github.io/post/2019/open-close/</link>
      <pubDate>Tue, 26 Jun 2018 23:17:56 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/open-close/</guid>
      <description>开闭原则 定义 OCP（Open Closed Principle）：软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification）。 这里的软件实体包括以下几个部分： 项目中划分出的模块 类与接口 方法 开闭原则的含义是：当应用的需求改变时，在不修改</description>
    </item>
    <item>
      <title>设计模式</title>
      <link>https://kunpengdai.github.io/post/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 26 Jun 2018 08:25:28 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 设计模式是前辈们对于代码开发经验的总结，是解决特定问题的一种固定套路。本质上还是对面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。设计模式最终要做到的就是将变化的部分和不变的部分隔离开来。 设计模式有两个核心理念： Program to an “int</description>
    </item>
    <item>
      <title>部署ngrok</title>
      <link>https://kunpengdai.github.io/post/2019/%E9%83%A8%E7%BD%B2ngrok/</link>
      <pubDate>Fri, 30 Jun 2017 15:37:14 +0800</pubDate>
      <guid>https://kunpengdai.github.io/post/2019/%E9%83%A8%E7%BD%B2ngrok/</guid>
      <description>ngrok ngrok可以让本地的web服务或tcp服务和外部建立一个安全的通道，使得外网可以访问本地的计算机服务。不仅可以用来暴露内网的http给外网使用，还可以从外网来ssh到本机开发环境。ngrok可以通过官方的服务来连接，也可以自己来。下面介绍下私有的ngrok服务的搭建工作。 准备</description>
    </item>
  </channel>
</rss>
